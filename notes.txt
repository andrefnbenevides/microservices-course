####################################################################################################################################
#######################				                                                                         #######################
#######################			                        	        KUBERNETES			     	             #######################
#######################				                                                                         #######################	
####################################################################################################################################

###########################
###
### Set up a pod
###
###########################

In the root of your project/solution create a folder named K8S, this file will contain our kubernetes files
Create a file inside K8S named: platforms-depl.yaml
Configure this file as necessary.

To deploy your platforms service, run the following command inside the K8S folder:
	> kubectl apply -f playforms-depl.yaml.

----

To verify if it was deployed successfully run the command:
	> kubectl get deployments

You should be able to see platforms-depl there, notice that READY is 0/1 that means that the container is still not running
Dont worry kubernetes is attempting to run it.

To get the pods for your platform-depl run:

	> kubectl get pods

Hopefully by now if you run again the get deplyoments you will see that it is now READY (1/1)
This means that kubernetes has managed to get the container to run.

If you destroy the deployed container. (IE delete it in docker desktop app)
Kubernetes will restore the container. 
This happens because we specified in the yaml file that we need to have 1 replica running at all times. 
So kubernetes will attempto keep one replica always running.


If you want to delete your deployment successfully without having kubernetes attempt to restore it automatically
you can do so by running the delete command:
	> kubectl delete deployment <your-deployment>

To make sure you get the right deployment first run:
	> kubectl get deployments

Check the name of the deployment you want to delete, in this case assum its name is "platforms-depl", then run:
	> kubectl delete deployment platforms-depl
	

###########################
###
### Set up a node port
###
###########################

Create a file named platforms-np-srv.yaml inside K8S

After creating the file run:
	> kubectl apply -f platforms-np-srv.yaml

To make sure that your service is created you can run:
	> kubectl get services


###########################
###
### Redeployment of app
###
###########################

After making changes in your code you'll need to redeploy the image
The following commands will build your image and push it to docker hub:
	> docker build -t <your-dockerhub-id>/<your-service> .
	> docker push <your-dockerhub-id>/<your-service>

Once the image has been pushed to docker hub, you'll need to request your kubernetes instance to restart.
This will force the instance to fetch the changes from docker hub before running again:
	> kubectl rollout restart deployment <your-service>





####################################################################################################################################
#######################				                                                                         #######################
#######################			                        	        Messaging			     	             #######################
#######################				                                                                         #######################	
####################################################################################################################################

***
** Synchronous Messaging
***
Request/Response cycle
Requester waits for response
Externally facing services are usually synchronous 
Services usually need to know about each other
Some forms of synchronous commuinication: http and grpc
Can cause inter-service dependency chains

***
** Asynchronous Messaging
***
No Request/Response cycle
Request does not wait for response
Data is transfered by eventing. (e.g. pub-sub)
Event bus is usually used (e.g. rabbitmq)
Services are unaware of each other, only the event bus knows where are the services
Good but not perfect, introduces other complexities and issues that do not exist in synchronous messaging




####################################################################################################################################
#######################				                                                                         #######################
#######################					             Building an API Gateway			     	             #######################
#######################				                                                                         #######################	
####################################################################################################################################


###########################
###
### Setup ingress-nginx deployment
###
###########################

you can use ingress nginx (reads as engine x).
Go to https://github.com/kubernetes/ingress-nginx and search for the Getting Started link.
It will forward you to the installation guide of the ingress nginx, at this time you should pick whatever is what you are using.
If you are just building the app on your pc, you will probably be using docker desktop so click on that link.

	> kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.0.0/deploy/static/provider/cloud/deploy.yaml

You will notice that if you do :
	> kubectl get deployments
	> kubectl get pods
That you will not be able to see any pods or deployments of nginx, that is because kubernetes uses namespaces
and when we ran those commands those were ran on the "default" namespace, which is the namespace that you have been working it since the beginning

if we run:
	> kubectl get namespace

You will see all the existing namespaces, including one "ingress-nginx"
So, to be able to see the pods and deployments of ingress-nginx we need to type the command like so:
	> kubectl get pods --namespace=ingress-nginx

Generic command:
	> kubectl get pods --namespace=<namespace-you-want-to-see>

This is all you need to do to create a load balancer/API Gateway, now we need to creating the routing so that the ingress-nginx knows
where to it should route traffic.


###########################
###
### Create routing  for ingress-nginx
###
###########################

Inside your K8S folder, create a new file named 'ingress-srv.yaml'
Configure it accordingly to the services you have and want to route to.

After that we need to open our hosts file to redirect traffic from acme.com to the loopback ip



